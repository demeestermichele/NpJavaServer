package com.dione.npjavaserver.controller;

import com.dione.npjavaserver.model.Charac;
import com.dione.npjavaserver.model.Role;
import com.dione.npjavaserver.model.Sex;
import com.dione.npjavaserver.repository.CharacRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.convert.ConversionFailedException;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.Set;

@Controller
@RequestMapping("/characters")
@CrossOrigin(origins = "*")
public class CharacterController {

    private final CharacRepository characRepository;

    @Autowired
    public CharacterController(CharacRepository characRepository) {
        this.characRepository = characRepository;
    }


    @GetMapping("/characterList")
    public String showCharacterList(Model model) {
        model.addAttribute("characters", characRepository.findAll());
        return "characters/character-list";
    }

    /**
     * Add new character to table "character"
     * @return verification message.
     * @throws Exception for try-catch
     */
    @PostMapping("/add")
    public String addCharacter(@Valid Charac charac, BindingResult result, Model model){
        if (result.hasErrors()) {
            return "add-character";
        }

        characRepository.save(charac);
        model.addAttribute("charac", characRepository.findAll());
        return "redirect:/index";
    }

    /**
     * Patch works using PostMapping. Will automatically create new character in the event that the intended character doesn't exist.
     *
     * @param id     Integer id of the character, this is only a search parameter and not post, ids are autogenerated.
     * @param first  String first name of the character.
     * @param last   String last name of the character.
     * @param role   Enumeration what role does the character play in the story options: PROTAGONIST, ANTAGONIST, SIDE, BACKGROUND, THROWAWAY
     * @param sex    Enumeration what is the sex of the character, options: MALE, FEMALE, THERIAN (shape-shifter)
     * @param mother Character the biological mother of the character, input the ID of the mother
     * @param father Character the biological father of the character, input the ID of the father
     * @return String to verify that patch worked
     * @throws Exception for try-catch, so the program doesn't crash all the time
     */
    @PostMapping("/patch")
    public String patchCharacter(@RequestParam Integer id, @RequestParam String first, @RequestParam String last, @RequestParam Role role, @RequestParam Sex sex, @RequestParam Charac mother, @RequestParam Charac father) throws Exception {
        Charac character = findCharacterById(id);
        if (character == null) {
            character = new Charac();
//            this.addCharacter(first, last, role, sex, mother, father);
        } else {
            if (character.getFirstName() != null) {
                character.setFirstName(first);
            }
            if (character.getLastName() != null) {
                character.setLastName(last);
            }
            if (character.getRole() != null) {
                try {
                    //do this in client
                    // String role1 = role.toString().toUpperCase();
                    character.setRole(role);
                } catch (ConversionFailedException e) {
                    System.err.println("unable to set role");
                }
            }
            if (character.getSex() != null) {
                try {
                    character.setSex(sex);
                } catch (Exception e) {
                    System.err.println("error " + e);
                    throw new Exception();
                }
            }
            if (character.getMother() != null) {
                if (mother.getSex() != Sex.MALE) {
                    try {
                        character.setMother(mother);

                    } catch (Exception e) {
                        throw new Exception(mother.getFirstName() + " is male.");
                    }
                }
                if (character.getFather() != null) {
                    if (father.getSex() != Sex.FEMALE) {
                        try {
                            character.setFather(father);
                        } catch (Exception e) {
                            throw new Exception(father.getFirstName() + " is female");
                        }
                    }
                }
            }
        }
        characRepository.save(character);
        return "Character updated";
    }

    /**
     * GET list of all objects in table "character"
     *
     * @return json list of characters
     */
/*
    @GetMapping("/list")
    public List<Charac> getCharacters() {
        return (List<Charac>) characRepository.findAll();
    }
*/

    public Charac findCharacterById(Integer id) {
        return characRepository.findCharacById(id);
    }

    @GetMapping("/{id}")
    public String showUpdateForm(@PathVariable("id") Integer id, Model model) {
        Charac charac = characRepository.findById(id).orElseThrow(() -> new IllegalArgumentException("Invalid character Id:" + id));
        model.addAttribute("charac", charac);
        return "characters/character";
    }


    /**
     * find all characters with the same parent id
     *
     * @param id of the character whose kids we want to find
     * @return list of characters from the id of parent
     */
    @GetMapping("/{id}/children")
    public Set<Charac> getChildren(@PathVariable Integer id) {
        if (findCharacterById(id).getSex() == Sex.FEMALE) {
            return characRepository.findCharacsByMother(characRepository.findCharacById(id));
        } else if (findCharacterById(id).getSex() == Sex.MALE) {
            return characRepository.findCharacsByFather(characRepository.findCharacById(id));
        } else if (findCharacterById(id).getSex() == Sex.THERIAN) {
            Set<Charac> charSex = characRepository.findCharacsByFather(characRepository.findCharacById(id));
            charSex.addAll(characRepository.findCharacsByMother(characRepository.findCharacById(id)));
            return charSex;
        } else {
            return null;
        }

    }

}
